#! /usr/bin/python
# -*- coding: latin-1 -*-
# $Id: makeintex 34 2005-10-25 11:31:35Z mtr $
"""

Copyright (C) 2005, 2006 by Martin Thorsen Ranang
"""

__revision__ = "$Rev: 34 $"
__author__ = "Martin Thorsen Ranang"

from itertools import count, cycle, izip
import logging
import optparse
import os
import re
import sys
import tempfile

INTEX_INDEX = 'raw'
INTEX_EXT = 'intex'

READ_BUF_SIZE = 4096

intex_re = re.compile('\\\@writefile\{%s\}' \
                      '\{\\\indexentry\{(?P<key>.*)\}\{(?P<page>\d+)\}\}' \
                      % (INTEX_INDEX))

def parse_command_line(command_line_options):
    """
    Parse the command line according to the possible COMMAND_LINE_OPTIONS.
    """
    #class Options(object):
    #    def __init__(self, args):
    #        for key, value in args.items():
    #            setattr(self, key, value)
    
    parser = optparse.OptionParser(usage = '%prog [options]...',
                                   version = '%%prog %s' % (__revision__))
    for option, description in command_line_options:
        parser.add_option(*option, **description)
        
    # Parse the command line.
    options, args = parser.parse_args()
    #return #Options(eval(str(options))), eval(str(args))
    return options, args
    
class Concept(object):
    """
    A class representing a single concept.
    """
    def __init__(self, key='', in_text='',
                 equivalencies=None, sort_as='', kind=None, serial=None):
        self.__key = key
        self.__serial = serial
        self.__in_text = in_text
        self.__equivalencies = equivalencies and equivalencies or list()
        self.__sort_as = sort_as
        self.__kind = None
        self.kind = kind
        
    def __str__(self):
        return '%(class)s("%(key)s", ' \
               'serial=%(serial)s, ' \
               'in_text="%(in_text)s", ' \
               'equivalencies=%(equivalencies)s, ' \
               'sort_as="%(sort_as)s", ' \
               'kind="%(kind)s")' \
               % dict(list(self.__dict__.items())
                      + [('class', self.__class__.__name__)])
    
    __repr__ = __str__
    
    def add_equivalency(self, equivalency):
        """
        Add a concept that is defined to be equivalent/synonymous with
        SELF.
        """
        self.__equivalencies.append(equivalency)

    def get_key(self):
        """
        Read accessor.  Returns private member __key.
        """
        return self.__key

    key = property(get_key, )

    def get_in_text(self):
        """
        Read accessor.  Returns private member __in_text.
        """
        return self.__in_text

    in_text = property(get_in_text, )
    
    def get_kind(self):
        """
        Read accessor that returns what kind of acronym this is.
        """
        return self.__kind
    
    def set_kind(self, kind):
        """
        An accessor method that safely declares what KIND of concept
        this object represents.
        """
        if kind not in set(['acronym', 'person', 'plain',
                            'equivalency', 'concept' # Not sure about these 2.
                            ]):
            raise KeyError, 'unknown kind of concept "%s"' % (kind, )
        else:
            self.__kind = kind
            
    kind = property(get_kind, set_kind, )
    
    def get_keys(self):
        """
        A generator accessor that yields the key of each concept
        equivalent with the current one.
        """
        yield self.__key
        
        for equivalent in self.__equivalencies:
            yield equivalent.__key

    keys = property(get_keys, )
    
    def get_equivalency(self, key):
        """
        Return the first equivalent concept that has a key that
        matches KEY.
        """
        if key != self.__key:
            for equivalency in self.__equivalencies:
                if equivalency.__key == key:
                    return equivalency
        return None
    
    def generate_index_entries(self, key, page):
        """
        Generate all the index entries for this concept.
        """
        equivalency = self.get_equivalency(key)
        
        args = dict(izip(('subentry', 'sort_as', 'concept', 'page'),
                         cycle([''])))
        
        args['index_name'] = 'raw'
        args['page'] = page
        
        if self.__kind == 'acronym':
            args['concept'] = self.__in_text[0]                
                
        elif self.__kind == 'person':
            args['concept'] = ', '.join(self.__in_text)
        else:
            args['concept'] = self.__key

        if self.__sort_as:
            args['sort_as'] = '%s@' % (self.__sort_as)
        
        if equivalency:
            for part in equivalency.__in_text:
                if part[0] == ':':
                    args['subentry'] = '!%s' % (part[1:])
            if equivalency.__sort_as:
                args['sort_as'] = '%s@' % (equivalency.__sort_as)
                
        res = '\indexentry{%(sort_as)s%(concept)s%(subentry)s}{%(page)s}' \
              % (args)
        
        if self.__kind == 'acronym':
            if len(self.__in_text) > 1:
                args['typeset'] =  '@' + self.__in_text[1]
            else:
                args['typeset'] = ''
                
            args['acronym'] = self.__key
            res += '\n\indexentry{%(acronym)s%(typeset)s' \
                   '|see{%(concept)s}}{%(page)s}' % (args)
        
        return res

    def get_typeset(self):
        """
        Accessor that returns instructions as for how this concept
        should be typeset in the index.
        """
        if len(self.__in_text) > 1:
            return '@' + self.__in_text[1]
        else:
            return ''

    typeset = property(get_typeset, )
    
    @staticmethod
    def get_full_form_and_typeset_as(in_text):
        """
        Returns the full-form of this concept and how it should be
        typeset in running text.
        """
        candidates = [field for field in in_text if field[0] != [':']]
        num_candidates = len(candidates) 
            
        if num_candidates == 0:
            return (None, None)
        elif num_candidates == 1:
            return (candidates[0], None)
        else:
            return (candidates[0], candidates[1])
        
    def expand_typeset_info(self, args):
        for arg in args:
            if arg and (arg[0] == '#'):
                if arg[1] == 'y':
                    full = self.__in_text[0]
                    if full[-1] == 'y':
                        yield full[:-1] + 'ies'
                    else:
                        logging.warning("'y' --> 'ies' transformation " \
                                        "specified, but 'y' not last in " \
                                        "full-form ('%s')", full)
                elif arg[1] == 's':
                    yield full + 's'
            else:
                yield arg
                
    def generate_aux_modifications(self, key, page):
        res = []
        if self.__kind == 'concept':
            #res.append('\\new%s{%s}{%d}{%s}{}' \
            #        % (self.__kind, self.__key, self.__serial, self.__key))
            res.append('\\new%s{%s}{%s}{}' \
                       % (self.__kind, self.__key, self.__key))
            equiv = self.get_equivalency(key)
            if equiv:
                #res.append('\\new%sequiv{%s}{%d}{%s}{%s}{}' \
                #           % (self.__kind, self.__key,
                #              self.__serial, equiv.__key, equiv.__key))
                res.append('\\new%sequiv{%s}{%s}{%s}{}' \
                           % (self.__kind, self.__key,
                              equiv.__key, equiv.__key))
                
        kinds = {'acronym': 'acronym',
                 'person': 'person',}
        if self.__kind in kinds:
            if len(self.__in_text) > 1:
                typeset_as = self.__in_text[1]
            else:
                typeset_as = self.__key
            res.append('\\new%s{%s}{%s}{%s}' \
                       % (kinds[self.__kind], self.__key, typeset_as,
                          self.__in_text[0]))
            
            equiv = self.get_equivalency(key)
            if equiv:
                (full_form, typeset_as) = \
                            self.expand_typeset_info(\
                    self.get_full_form_and_typeset_as(equiv.__in_text))

                if not full_form:
                    full_form = self.__in_text[0]
                if not typeset_as:
                    typeset_as = (self.__kind == 'person') \
                                 and self.__in_text[1] \
                                 or full_form
                    
                res.append('\\new%sequiv{%s}{%s}{%s}{%s}' \
                           % (kinds[self.__kind], self.__key, typeset_as,
                              equiv.__key, full_form))
                
        return res

class Equivalency(Concept):
    def __init__(self, key='', in_text='',
                 equivalencies=list(), sort_as=None, serial=None):
        super(self.__class__, self).__init__(key, in_text,
                                             equivalencies, sort_as,
                                             'equivalency', serial=serial)
        
class InTeX(object):
    delimiter = '\t'
    
    def __init__(self, filenames):
        identifiers = dict()
        
        for filename in filenames:
            identifiers[filename] = self.parse(filename)
            
        self.index = dict()
        seen_kinds = dict()
        
        for filename, concepts in identifiers.items():
            for concept in concepts:
                seen_kinds[concept.kind] = True
                for key in concept.get_keys():
                    self.index[key] = concept
        
        self.identifiers = identifiers
        self.used_kinds = tuple(seen_kinds)
        
    def __contains__(self, key):
        return self.index.__contains__(key)

    def __getitem__(self, key):
        return self.index.__getitem__(key)

    @staticmethod
    def handle_fields(fields, kind, serial_number):
        info = {'serial': serial_number}
        
        key, fields = fields[0], fields[1:]
        
        info['key'] = key
        
        if fields and fields[-1][0] == '@':
            info['sort_as'] = fields.pop()[1:]

        info['in_text'] = tuple(fields)
        
        info['kind'] = kind

        #print >> sys.stderr, "Found info:", info
        return info

    def parse_line(self, line, concepts, kind, serial_number=0):
        if line[0].isspace():
            # An equivalent form of the current index entry.
            fields = self.handle_fields(line.lstrip().split(self.delimiter),
                                        kind, serial_number)
            del fields['kind']
            concepts[-1].add_equivalency(Equivalency(**fields))
            
        else:
            # A new index entry.  Can be 'person', 'acronym', or 'plain'.
            fields = self.handle_fields(line.split(self.delimiter),
                                        kind, serial_number)
            concepts.append(Concept(**fields))
            
    def parse(self, filename):
        concepts = []
        mode_switch_re = re.compile('^%[ ]*\*' \
                                    '(?P<kind>persons|acronyms|concepts)\*',
                                    re.IGNORECASE)
        kind = 'concept'                # Default "mode".

        serial_number = 1
        in_file = open(filename, 'r')
        for line in in_file:
            line = line.rstrip("\n")
            if not line:
                continue
            if line[0] == '%':
                match = mode_switch_re.match(line)
                if match:
                    # New current KIND (or mode).
                    kind = match.group('kind')[:-1].lower()
                continue
            
            self.parse_line(line, concepts, kind, serial_number)
            serial_number += 1
            
        in_file.close()
        
        return concepts

def get_entries(filename):
    for line in open(filename, 'r'):
        match = intex_re.match(line.rstrip())
        if not match:
            yield (False, line)
            continue
        yield (True, match.groups())
        
def handle_auxiliary(aux_filename, index, index_file, tmp_aux_file):
    not_found = []
    already_handled = set()
    already_printed = set()
    
    for is_concept, data in get_entries(aux_filename):
        if not is_concept:
            tmp_aux_file.write(data)
            continue
        
        key, page = data
        
        if key not in index:
            not_found.append((key, page))
            continue
        
        concept = index[key]
        print >> index_file, concept.generate_index_entries(key, page)
        
        if key not in already_handled:
            aux_info = concept.generate_aux_modifications(key, page)
            for line in aux_info:
                if line not in already_printed:
                    print >> tmp_aux_file, line
                    already_printed.add(line)
                    
            already_handled.add(key)
            
    return not_found

def copy(src_name, dst_name):
    src, dst = open(src_name, 'r'), open(dst_name, 'w')
    while True:
        data = src.read(READ_BUF_SIZE)
        if data == '':
            break
        dst.write(data)
        
    dst.close()
    src.close()

auto_edit_warning = '''
%%%% This file was automatically generated by InTeX version %s,
%%%% copyright (C) 2005 by Martin Thorsen Ranang.  Any manual changes
%%%% made to this file will be lost next time InTeX is run with the
%%%% same arguments.
''' % (__revision__)

def generate_acrodefs(index):
    res = []
    for concepts in index.identifiers.values():
        for concept in concepts:
            if concept.kind == 'acronym':
                if len(concept.in_text) > 1:
                    typeset_as = concept.in_text[1]
                else:
                    typeset_as = concept.key
                    
                res.append('\\newacronym{%s}{%s}{%s}' \
                           % (concept.key, typeset_as,
                              concept.in_text[0]))
    return res

def generate_persondefs(index):
    res = []
    for concepts in index.identifiers.values():
        for concept in concepts:
            if concept.kind == 'person':
                if len(concept.in_text) > 1:
                    res.append('\\newperson{%s}{%s}{%s}' \
                               % (concept.key, concept.in_text[1],
                                  concept.in_text[0]))
                else:
                    res.append('\\newperson{%s}{%s}' \
                               % (concept.key, concept.in_text[0]))
    return res

def resolve_auxiliary_and_args(args):
    aux_re = re.compile('^.*\.aux$', re.IGNORECASE)
    auxiliary = [arg for arg in args
                 if aux_re.match(arg) and os.path.exists(arg)]
    args = [arg for arg in args if arg not in auxiliary]

    attempts = count(-2)
    
    while attempts.next():
        if len(auxiliary) > 1:
            logging.error('Please explicitly specify the ' \
                          'LaTeX auxiliary (.aux) file to use.')
            sys.exit(1)
            
        elif not auxiliary:
            auxiliary = ['%s.aux' % (arg) for arg in args
                         if os.path.exists('%s.aux' % (arg))]
            args = [arg for arg in args if '%s.aux' % (arg) not in auxiliary]
            
        else:
            auxiliary = auxiliary[0]
            break
        
    return auxiliary, args

def main():
    """
    Module mainline (for standalone execution).
    """
    command_line_options = [
        (['-o', '--index-output'],
         {'dest': 'index_output',
          'default': None,
          'metavar': 'FILE',
          'help': 'output the new indexing information to FILE'}),
        (['-a', '--acrodef-output'],
         {'dest': 'acrodef_output',
          'default': None,
          'metavar': 'FILE',
          'help': 'output acronym definitions to FILE'}),
        (['-p', '--persondef-output'],
         {'dest': 'persondef_output',
          'default': None,
          'metavar': 'FILE',
          'help': 'output (person) name definitions to FILE'}),
        (['-V', '--verbose'],
         {'dest': 'verbose',
          'default': False,
          'action': 'store_true',
          'help': 'whether or not to output verbose information'}),
        ]
    
    options, args = parse_command_line(command_line_options)
    
    auxiliary, args = resolve_auxiliary_and_args(args)
    
    if not auxiliary:
        logging.warning('No LaTeX auxiliary file specified.')
        sys.exit(1)
        
    if len(args) == 0:
        suffix_re = re.compile('^.*\.%s$' % (INTEX_EXT))
        
        filenames = [filename
                     for filename in os.listdir(os.getcwd())
                     if suffix_re.match(filename)]
    else:
        filenames = args
    
    for filename in filenames:
        if not os.path.exists(filename):
            print >> sys.stderr, "error: File '%s' not found" % (filename)
            return 1
        
    if options.verbose:
        print >> sys.stderr, 'LaTeX Auxiliary file: %s' % (auxiliary)
        print >> sys.stderr, 'Concept-files:\n%s' % '\n'.join(filenames)

    index = InTeX(filenames)

    for option, meta_information, kind in ((options.index_output,
                                            'index information',
                                            None),
                                           (options.acrodef_output,
                                            'acronym definitions',
                                            'acronym'),
                                           (options.persondef_output,
                                            '(proper)name definitions',
                                            'person')):
        if (kind and (kind in index.used_kinds) and (not option)):
            logging.error('Missing name for file wherein ' \
                          '%s will be stored.', meta_information)
            return 1
        elif (kind and option and (kind not in index.used_kinds)):
            logging.warning("name for file wherein " \
                            "%s will be stored was  supplied ('%s'), " \
                            "but no such input occur.",
                            meta_information, option)

    persondef_file = open(options.persondef_output, 'w')
    print >> persondef_file, auto_edit_warning
    print >> persondef_file, '\n'.join(generate_persondefs(index))
    persondef_file.close()
    
    acrodef_file = open(options.acrodef_output, 'w')
    print >> acrodef_file, auto_edit_warning
    print >> acrodef_file, '\n'.join(generate_acrodefs(index))
    acrodef_file.close()
    
    index_file = open(options.index_output, 'w')
    
    # We first create a temporary file.  If any "shit hits the fan"
    # before we're done, the original LaTeX .aux file will be
    # untouched and the temporary version can be inspected.
    tmp_aux_fd, tmp_aux_filename = tempfile.mkstemp('.%s' % (INTEX_EXT))
    tmp_aux_file = os.fdopen(tmp_aux_fd, 'w')
    
    not_found = handle_auxiliary(auxiliary, index,
                                 index_file, tmp_aux_file)

    index_file.close()
    tmp_aux_file.close()
    
    # Everything seems to have worked OK so far.  Now, let's backup
    # the original .aux file and rename the temporarily created one to
    # take the place of the original.
    os.rename(auxiliary, '%s~' % (auxiliary))
    copy(tmp_aux_filename, auxiliary)
    os.unlink(tmp_aux_filename)
    
    if not_found:
        logging.warning('The following phrases ' \
                        'could not be handled:\n%s',
                        ('\n'.join('%s\t%s' % item for item in not_found)))
        
    return

if __name__ == "__main__":
    main()
