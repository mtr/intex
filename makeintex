#! /usr/bin/python
# -*- coding: latin-1 -*-
# $Id$
"""

Copyright (C) 2005, 2006 by Martin Thorsen Ranang
"""

__revision__ = "$Rev$"
__author__ = "Martin Thorsen Ranang"

from itertools import count, cycle, ifilter, izip
import logging
import optparse
import os
import re
import sys
import tempfile

INTEX_INDEX = 'raw'
INTEX_EXT = 'intex'

READ_BUF_SIZE = 4096

intex_re = re.compile('\\\@writefile\{%s\}' \
                      '\{\\\indexentry\{(?P<key>.*)\}\{(?P<page>\d+)\}\}' \
                      % (INTEX_INDEX))

    
class Concept(object):
    """
    A class representing a single concept.
    """
    xname = 'blipp'
    def __init__(self, key='', in_text='', sort_as='', serial=None):
        self.__key = key
        self.__serial = serial
        self.__in_text = in_text
        self.__equivalencies = list() #equivalencies and equivalencies or list()
        self.__sort_as = sort_as
        self.__name = self.xname
        
    def __str__(self):
        return '%s("%s", "%s", %s, "%s", %s)' \
               % (self.__class__.__name__, self.key, self.in_text,
                  self.__equivalencies, self.sort_as, self.__serial)
                              
        return '%(class)s("%(key)s", ' \
               'serial=%(serial)s, ' \
               'in_text="%(in_text)s", ' \
               'equivalencies=%(equivalencies)s, ' \
               'sort_as="%(sort_as)s", ' \
               % dict(list(self.__dict__.items())
                      + [('class', self.__class__.__name__)])
    
    __repr__ = __str__

    def get_name(self):
        return self.__name

    name = property(get_name, )
    
    def add_equivalency(self, equivalency):
        """
        Add a concept that is defined to be equivalent/synonymous with
        SELF.
        """
        self.__equivalencies.append(equivalency)

    def get_key(self):
        """
        Read accessor.  Returns private member __key.
        """
        return self.__key

    key = property(get_key, )

    def get_in_text(self):
        """
        Read accessor.  Returns private member __in_text.
        """
        return self.__in_text

    in_text = property(get_in_text, )
    
    def get_keys(self):
        """
        A generator accessor that yields the key of each concept
        equivalent with the current one.
        """
        yield self.__key
        
        for equivalent in self.__equivalencies:
            yield equivalent.__key

    keys = property(get_keys, )
    
    def get_equivalencies(self):
        """
        Return the equivalent concepts of SELF.
        """
        return (equivalency
                for equivalency in self.__equivalencies)

    equivalencies = property(get_equivalencies, )

    def get_sort_as(self):
        """
        Read accessor.  Returns private member __sort_as.
        """
        return self.__sort_as

    sort_as = property(get_sort_as, )
    
    def generate_index_entries(self, key, page):
        """
        Generate all the index entries for this concept.
        """
        raise (NotImplementedError,
               'The %s class does not implement this method.' %
               self.__class__.__name__)

    def get_typeset(self):
        """
        Accessor that returns instructions as for how this concept
        should be typeset in the index.
        """
        if len(self.__in_text) > 1:
            return '@' + self.__in_text[1]
        else:
            return ''

    typeset = property(get_typeset, )
    
    @staticmethod
    def get_full_form_and_typeset_as(in_text):
        """
        Returns the full-form of this concept and how it should be
        typeset in running text.
        """
        candidates = [field for field in in_text if field[0] != [':']]
        num_candidates = len(candidates) 
            
        if num_candidates == 0:
            return (None, None)
        elif num_candidates == 1:
            return (candidates[0], None)
        else:
            return (candidates[0], candidates[1])
        
    def expand_typeset_info(self, parent, args):
        for arg in args:
            if arg and (arg[0] == '#'):
                full = parent.in_text and parent.in_text[0] or parent.key
                if arg[1] == 'y':
                    if full[-1] == 'y':
                        yield full[:-1] + 'ies'
                    else:
                        logging.warning("'y' --> 'ies' transformation " \
                                        "specified, but 'y' not last in " \
                                        "full-form ('%s')", full)
                elif arg[1] == 's':
                    yield full + 's'
            else:
                yield arg
                
    def generate_aux_modifications(self, key, page):
        raise (NotImplementedError,
               'The %s class does not implement this method.' %
               self.__class__.__name__)
    
    @staticmethod
    def is_plain():
        return False

    @staticmethod
    def is_acronym():
        return False

    @staticmethod
    def is_person():
        return False

    @staticmethod
    def is_equivalency():
        return False

    @staticmethod
    def _setup_index_args(index_name, page, concept, sort_as='',
                          sub_concept=''):
        return {
            'index_name': index_name,
            'page': page,
            'concept': concept,
            'sub_concept': sub_concept,
            'sort_as': sort_as and ('%s@' % (sort_as)) or '',
            }

    def generate_index_entries(self, index_name, page):
        """
        Generate all the index entries (including sub-entries) for
        this concept.
        """
        yield self.generate_index_entry(index_name, page)
        
        for equivalency in self.equivalencies:
            yield equivalency.generate_index_entry(index_name, page, self)
            
    def generate_aux_modifications(self):
        """
        Generate all the aux-file modifications (including
        sub-entries) for this concept.
        """
        yield self.generate_aux_modification()
        
        for equiv in self.equivalencies:
            yield equiv.generate_aux_modification(self)

class PlainConcept(Concept):
    xname = 'concept'
    
    @staticmethod
    def is_plain():
        return True
    
    def generate_index_entry(self, index_name, page):
        args = self._setup_index_args(index_name, page, self.key, self.sort_as)
        return '\indexentry{%(sort_as)s%(concept)s}{%(page)s}' % (args)
    
    def generate_aux_modification(self):
        return '\\new%s{%s}{%s}{}' % (self.name, self.key, self.key)
            
class AcronymConcept(Concept):
    xname = 'acronym'
    
    @staticmethod
    def is_acronym():
        return True

    def generate_index_entry(self, index_name, page):
        args = self._setup_index_args(index_name, page, self.in_text[0], self.sort_as)
        args['typeset_as'] = (len(self.in_text) > 1) and self.in_text[1] or self.key
        

        return '\indexentry{%(sort_as)s%(concept)s}{%(page)s}\n' \
               '\indexentry{%(typeset_as)s|see{%(concept)s}}{%(page)s}' \
               % (args)

    def generate_aux_modification(self):
        typeset_as = (len(self.in_text) > 1) and self.in_text[1] or self.key
        return '\\new%s{%s}{%s}{%s}' \
               % (self.name, self.key, typeset_as, self.in_text[0])
    
            
class PersonConcept(Concept):
    xname = 'person'
    
    @staticmethod
    def is_person():
        return True
    
class Equivalency(Concept):
    xname = 'equiv'
    
    @staticmethod
    def is_equivalency():
        return True
    
    def generate_index_entry(self, index_name, page, parent):
        sub_concept = ''
        for part in self.in_text:
            if part[0] == ':':
                sub_concept = '!%s' % (part[1:])
                
        args = self._setup_index_args(index_name, page, parent.key,
                                      self.sort_as, sub_concept)
        return '\\indexentry{%(sort_as)s%(concept)s%(sub_concept)s}{%(page)s}' \
               % (args)
    
    def generate_index_entries(self, **args):
        raise (NotImplementedError,
               'The %s class does not implement this method.' %
               self.__class__.__name__)
    
    def _modify_aux_args(self, args):
        return args
    
    def _setup_aux_args(self, concept, sub_concept=None):
        full_form, typeset_as = \
                   self.expand_typeset_info(\
            concept,
            self.get_full_form_and_typeset_as(self.in_text))

        #print 'self.in_text:', self.in_text, typeset_as, full_form
        
        if not full_form and self.in_text:
            full_form = self.in_text[0]

        if not typeset_as:
            typeset_as = self.key       # Should handle "IDs   #y" -> IDs
            
        return self._modify_aux_args({
            'name': self.name,
            'concept': concept.key,
            'sub_concept': sub_concept,
            'full_form': full_form,
            'typeset_as': typeset_as or full_form,
            'parent': concept,
            })
    
    def generate_aux_modification(self, parent):
        args = self._setup_aux_args(parent, self.key)

        return '\\new%(name)s{%(concept)s}{%(typeset_as)s}' \
               '{%(sub_concept)s}{%(full_form)s}' % (args)

    def generate_aux_modifications(self, **args):
        raise (NotImplementedError,
               'The %s class does not implement this method.' %
               self.__class__.__name__)
    
class PlainEquivalency(Equivalency):
    xname = 'conceptequiv'

    def _modify_aux_args(self, args):
        if args['full_form'][0] == ':':
            args['full_form'] = args['sub_concept']
        if args['typeset_as'][0] == ':':            
            args['typeset_as'] = args['sub_concept']
            
        return args
    
class AcronymEquivalency(Equivalency):
    xname = 'acronymequiv'

    def generate_index_entry(self, index_name, page, parent):
        sub_concept = ''
        for part in self.in_text:
            if part[0] == ':':
                sub_concept = '!%s' % (part[1:])
                
        args = self._setup_index_args(index_name, page, parent.in_text[0],
                                      self.sort_as, sub_concept)
        
        args['typeset_as'] = (len(self.in_text) > 1) \
                             and ('@' + self.in_text[1]) or ''
        
        return '\\indexentry{%(sort_as)s%(concept)s%(sub_concept)s}{%(page)s}' \
               % (args)

    def _modify_aux_args(self, args):
        parent = args['parent']
        
        if not args['full_form']:
            old = parent.in_text and parent.in_text[0] or parent.key
            added = args['sub_concept'].lstrip(args['concept'])
            args['full_form'] = old + added
            
        # If not SELF.IN_TEXT, then we've got no explicit typesetting
        # info.
        if (not self.in_text) or (not args['typeset_as']):
            old = parent.in_text and parent.in_text[1] or parent.key
            added = args['sub_concept'].lstrip(args['concept'])
            args['typeset_as'] = old + added
            
        return args
        
class PersonEquivalency(Equivalency):
    xname = 'personequiv'
    
    def modify_aux_args(self, args):
        args['typeset_as'] = self.in_text[1]
        return args

    
class InTeX(object):
    delimiter = '\t'
    
    def __init__(self, filenames):
        identifiers = dict()
        
        for filename in filenames:
            identifiers[filename] = self.parse(filename)
            
        self.index = dict()
        seen_kinds = set()
        
        for filename, concepts in identifiers.items():
            for concept in concepts:
                seen_kinds.add(concept.__class__.__name__)
                
                for key in concept.get_keys():
                    self.index[key] = concept
        
        self.identifiers = identifiers
        self.used_kinds = tuple(seen_kinds)

    def __str__(self):
        return str(self.index)
    
    def __contains__(self, key):
        return self.index.__contains__(key)

    def __getitem__(self, key):
        return self.index.__getitem__(key)

    @staticmethod
    def handle_fields(fields, serial_number):
        info = {'serial': serial_number}
        
        key, fields = fields[0], fields[1:]
        
        info['key'] = key
        
        if fields and fields[-1][0] == '@':
            info['sort_as'] = fields.pop()[1:]

        info['in_text'] = tuple(fields)
        
        #info['kind'] = kind

        return info

    __kind_class_map = {
        'person': PersonConcept,
        'acronym': AcronymConcept,
        'concept': PlainConcept,
        'person_equiv': PersonEquivalency,
        'acronym_equiv': AcronymEquivalency,
        'concept_equiv': PlainEquivalency,
        }
    
    def parse_line(self, line, concepts, kind, serial_number=0):
        if line[0].isspace():
            # An equivalent form of the current index entry.
            kind = '%s_equiv' % (kind, )
            fields = self.handle_fields(line.lstrip().split(self.delimiter),
                                        serial_number)
            #del fields['kind']
            concepts[-1].add_equivalency(self.__kind_class_map[kind](**fields))
            
        else:
            # A new index entry.  Can be 'person', 'acronym', or 'plain'.
            fields = self.handle_fields(line.split(self.delimiter),
                                        serial_number)
            concepts.append(self.__kind_class_map[kind](**fields))
            
    def parse(self, filename):
        concepts = []
        mode_switch_re = re.compile('^%[ ]*\*' \
                                    '(?P<kind>persons|acronyms|concepts)\*',
                                    re.IGNORECASE)
        kind = 'concept'                # Default "mode".

        serial_number = 1
        in_file = open(filename, 'r')
        for line in in_file:
            line = line.rstrip("\n")
            if not line:
                continue
            if line[0] == '%':
                match = mode_switch_re.match(line)
                if match:
                    # New current KIND (or mode).
                    kind = match.group('kind')[:-1].lower()
                continue
            
            self.parse_line(line, concepts, kind, serial_number)
            serial_number += 1
            
        in_file.close()
        
        return concepts

def get_entries(filename):
    for line in open(filename, 'r'):
        match = intex_re.match(line.rstrip())
        if not match:
            yield (False, line)
            continue
        yield (True, match.groups())
        
def handle_auxiliary(aux_filename, index, index_file, tmp_aux_file):
    not_found = []
    already_handled = set()
    already_printed = set()
    
    for is_concept, data in get_entries(aux_filename):
        if not is_concept:
            tmp_aux_file.write(data)
            continue
        
        key, page = data
        
        if key not in index:
            not_found.append((key, page))
            continue
        
        concept = index[key]

        for line in concept.generate_index_entries(INTEX_INDEX, page):
            if line not in already_printed:
                print >> index_file, line
                already_printed.add(line)
                
        if key not in already_handled:
            for line in concept.generate_aux_modifications():
                if line not in already_printed:
                    print >> tmp_aux_file, line
                    already_printed.add(line)
                    
            already_handled.add(key)
            
    return not_found

def copy(src_name, dst_name):
    src, dst = open(src_name, 'r'), open(dst_name, 'w')
    while True:
        data = src.read(READ_BUF_SIZE)
        if data == '':
            break
        dst.write(data)
        
    dst.close()
    src.close()

auto_edit_warning = '''
%%%% This file was automatically generated by InTeX version %s,
%%%% copyright (C) 2005, 2006 by Martin Thorsen Ranang.  Any manual changes
%%%% made to this file will be lost next time InTeX is run with the
%%%% same arguments.
''' % (__revision__)

def generate_acrodefs(index):
    res = []
    for concepts in index.identifiers.values():
        for concept in ifilter(lambda concept: concept.is_acronym(), concepts):
            if len(concept.in_text) > 1:
                typeset_as = concept.in_text[1]
            else:
                typeset_as = concept.key

            res.append('\\newacronym{%s}{%s}{%s}' \
                       % (concept.key, typeset_as,
                          concept.in_text[0]))
    return res

def generate_persondefs(index):
    res = []
    for concepts in index.identifiers.values():
        for concept in ifilter(lambda concept: concept.is_person(), concepts):
            if len(concept.in_text) > 1:
                res.append('\\newperson{%s}{%s}{%s}' \
                           % (concept.key, concept.in_text[1],
                              concept.in_text[0]))
            else:
                res.append('\\newperson{%s}{%s}' \
                           % (concept.key, concept.in_text[0]))
    return res

def resolve_auxiliary_and_args(args):
    aux_re = re.compile('^.*\.aux$', re.IGNORECASE)
    auxiliary = [arg for arg in args
                 if aux_re.match(arg) and os.path.exists(arg)]
    args = [arg for arg in args if arg not in auxiliary]

    attempts = count(-2)
    
    while attempts.next():
        if len(auxiliary) > 1:
            logging.error('Please explicitly specify the ' \
                          'LaTeX auxiliary (.aux) file to use.')
            sys.exit(1)
            
        elif not auxiliary:
            auxiliary = ['%s.aux' % (arg) for arg in args
                         if os.path.exists('%s.aux' % (arg))]
            args = [arg for arg in args if '%s.aux' % (arg) not in auxiliary]
            
        else:
            auxiliary = auxiliary[0]
            break
        
    return auxiliary, args


def parse_command_line(command_line_options):
    """
    Parse the command line according to the possible COMMAND_LINE_OPTIONS.
    """
    parser = optparse.OptionParser(usage = '%prog [options]...',
                                   version = '%%prog %s' % (__revision__))
    for option, description in command_line_options:
        parser.add_option(*option, **description)
        
    # Parse the command line.
    options, args = parser.parse_args()
    return options, args


def main():
    """
    Module mainline (for standalone execution).
    """
    command_line_options = [
        (['-o', '--index-output'],
         {'dest': 'index_output',
          'default': None,
          'metavar': 'FILE',
          'help': 'output the new indexing information to FILE'}),
        (['-a', '--acrodef-output'],
         {'dest': 'acrodef_output',
          'default': None,
          'metavar': 'FILE',
          'help': 'output acronym definitions to FILE'}),
        (['-p', '--persondef-output'],
         {'dest': 'persondef_output',
          'default': None,
          'metavar': 'FILE',
          'help': 'output (person) name definitions to FILE'}),
        (['-V', '--verbose'],
         {'dest': 'verbose',
          'default': False,
          'action': 'store_true',
          'help': 'whether or not to output verbose information'}),
        ]
    
    options, args = parse_command_line(command_line_options)
    
    auxiliary, args = resolve_auxiliary_and_args(args)

    logging.root.name = sys.argv[0]
    
    if not auxiliary:
        logging.warning('No LaTeX auxiliary file specified.')
        sys.exit(1)
        
    if len(args) == 0:
        suffix_re = re.compile('^.*\.%s$' % (INTEX_EXT))
        
        filenames = [filename
                     for filename in os.listdir(os.getcwd())
                     if suffix_re.match(filename)]
    else:
        filenames = args
    
    for filename in filenames:
        if not os.path.exists(filename):
            logging.error("File '%s' not found", filename)
            sys.exit(1)
            
    if options.verbose:
        logging.info('LaTeX Auxiliary file: %s', auxiliary)
        logging.info('Concept-files:\n%s', '\n'.join(filenames))
        
    index = InTeX(filenames)

    for option, meta_information, kind in ((options.index_output,
                                            'index information',
                                            'PlainConcept'),
                                           (options.acrodef_output,
                                            'acronym definitions',
                                            'AcronymConcept'),
                                           (options.persondef_output,
                                            '(proper)name definitions',
                                            'PersonConcept')):
        if (kind and (kind in index.used_kinds) and (not option)):
            logging.error('Missing name for file wherein ' \
                          '%s will be stored.', meta_information)
            return 1
        elif (kind and option and (kind not in index.used_kinds)):
            logging.warning("name for file wherein " \
                            "%s will be stored was  supplied ('%s'), " \
                            "but no such input occur.",
                            meta_information, option)
            
    persondef_file = open(options.persondef_output, 'w')
    print >> persondef_file, auto_edit_warning
    print >> persondef_file, '\n'.join(generate_persondefs(index))
    persondef_file.close()
    
    acrodef_file = open(options.acrodef_output, 'w')
    print >> acrodef_file, auto_edit_warning
    print >> acrodef_file, '\n'.join(generate_acrodefs(index))
    acrodef_file.close()
    
    index_file = open(options.index_output, 'w')
    
    # We first create a temporary file.  If any "shit hits the fan"
    # before we're done, the original LaTeX .aux file will be
    # untouched and the temporary version can be inspected.
    tmp_aux_fd, tmp_aux_filename = tempfile.mkstemp('.%s' % (INTEX_EXT))
    tmp_aux_file = os.fdopen(tmp_aux_fd, 'w')
    
    not_found = handle_auxiliary(auxiliary, index,
                                 index_file, tmp_aux_file)

    index_file.close()
    tmp_aux_file.close()
    
    # Everything seems to have worked OK so far.  Now, let's backup
    # the original .aux file and rename the temporarily created one to
    # take the place of the original.
    os.rename(auxiliary, '%s~' % (auxiliary))
    copy(tmp_aux_filename, auxiliary)
    os.unlink(tmp_aux_filename)
    
    if not_found:
        logging.warning('The following phrases ' \
                        'could not be handled:\n%s',
                        ('\n'.join('%s\t%s' % item for item in not_found)))
        
    return

if __name__ == "__main__":
    main()
