#! /usr/bin/python
# -*- coding: latin-1 -*-
# $Id: makeintex 34 2005-10-25 11:31:35Z mtr $
"""

Copyright (C) 2005 by Martin Thorsen Ranang
"""

__version__ = "$Rev: 34 $"
__author__ = "Martin Thorsen Ranang"

import itertools
import optparse
import os
import re
import sys
import tempfile

INTEX_INDEX = 'raw'
INTEX_EXT = 'intex'

READ_BUF_SIZE = 4096

intex_re = re.compile('\\\@writefile\{%s\}' \
                      '\{\\\indexentry\{(?P<key>.*)\}\{(?P<page>\d+)\}\}' \
                      % (INTEX_INDEX))

def parse_command_line(command_line_options):
    class Options(object):
        def __init__(self, args):
            for key, value in args.items():
                setattr(self, key, value)
                
    parser = optparse.OptionParser(usage = '%prog [options]...',
                                   version = '%%prog %s' % (__version__))
    for option, description in command_line_options:
        parser.add_option(*option, **description)
        
    # Parse the command line.
    options, args = parser.parse_args()
    return Options(eval(str(options))), eval(str(args))
    
class Concept(object):
    def __init__(self, key='', in_text='',
                 equivalencies=None, sort_as='', kind=None, serial=None):
        self.key = key
        self.serial = serial
        self.in_text = in_text
        self.equivalencies = equivalencies and equivalencies or list()
        self.sort_as = sort_as
        self.kind = kind
        #print >>sys.stderr, str(self)
        
    def __str__(self):
        return '%(class)s("%(key)s", ' \
               'serial=%(serial)s, ' \
               'in_text="%(in_text)s", ' \
               'equivalencies=%(equivalencies)s, ' \
               'sort_as="%(sort_as)s", ' \
               'kind="%(kind)s")' \
               % dict(list(self.__dict__.items())
                      + [('class', self.__class__.__name__)])
    
    __repr__ = __str__
    
    def add_equivalency(self, equivalency):
        self.equivalencies.append(equivalency)
        
    def set_kind(self, kind):
        if kind not in ['acronym', 'person', 'plain']:
            raise KeyError, 'unknown kind of concept'
        else:
            self.kind = kind

    def get_keys(self):
        yield self.key
        for equivalent in self.equivalencies:
            yield equivalent.key

    def get_equivalency(self, key):
        if key != self.key:
            for equivalency in self.equivalencies:
                if equivalency.key == key:
                    return equivalency
        return None
    
    def generate_index_entries(self, key, page):
        equivalency = self.get_equivalency(key)
        
        args = dict(zip(('subentry', 'sort_as', 'concept', 'page'),
                        itertools.cycle([''])))

        args['index_name'] = 'raw'
        args['page'] = page
        
        if self.kind == 'acronym':
            args['concept'] = self.in_text[0]                
                
        elif self.kind == 'person':
            args['concept'] = ', '.join(self.in_text)
        else:
            args['concept'] = self.key

        if self.sort_as:
            args['sort_as'] = '%s@' % (self.sort_as)
        
        if equivalency:
            for part in equivalency.in_text:
                if part[0] == ':':
                    args['subentry'] = '!%s' % (part[1:])
            if equivalency.sort_as:
                args['sort_as'] = '%s@' % (equivalency.sort_as)
                
        res = '\indexentry{%(sort_as)s%(concept)s%(subentry)s}{%(page)s}' \
              % (args)
        
        if self.kind == 'acronym':
            if len(self.in_text) > 1:
                args['typeset'] =  '@' + self.in_text[1]
            else:
                args['typeset'] = ''
                
            args['acronym'] = self.key
            res += '\n\indexentry{%(acronym)s%(typeset)s' \
                   '|see{%(concept)s}}{%(page)s}' % (args)
        
        return res

    def get_typeset(self):
        if len(self.in_text) > 1:
            return '@' + self.in_text[1]
        else:
            return ''

    def get_full_form_and_typeset_as(self, in_text):
        candidates = [field for field in in_text if field[0] != [':']]
        num_candidates = len(candidates) 
            
        if num_candidates == 0:
            return (None, None)
        elif num_candidates == 1:
            return (candidates[0], None)
        else:
            return (candidates[0], candidates[1])
        
    def get_index_as(self, in_text):
        for field in in_text:
            if field[0] == [':']:
                return field

    def expand_typeset_info(self, args):
        for arg in args:
            if arg and (arg[0] == '#'):
                if arg[1] == 'y':
                    full = self.in_text[0]
                    if full[-1] == 'y':
                        yield full[:-1] + 'ies'
                    else:
                        print >>sys.stderr, \
                              "Warning, 'y' --> 'ies' transformation " \
                              "specified, but 'y' not last in full-form. "\
                              "('%s')" % (full)
                elif arg[1] == 's':
                    yield full + 's'
            else:
                yield arg
                
    def generate_aux_modifications(self, key, page):
        res = []
        if self.kind == 'concept':
            #res.append('\\new%s{%s}{%d}{%s}{}' \
            #        % (self.kind, self.key, self.serial, self.key))
            res.append('\\new%s{%s}{%s}{}' \
                       % (self.kind, self.key, self.key))
            equiv = self.get_equivalency(key)
            if equiv:
                #res.append('\\new%sequiv{%s}{%d}{%s}{%s}{}' \
                #           % (self.kind, self.key,
                #              self.serial, equiv.key, equiv.key))
                res.append('\\new%sequiv{%s}{%s}{%s}{}' \
                           % (self.kind, self.key,
                              equiv.key, equiv.key))
                
        kinds = {'acronym': 'acronym',
                 'person': 'person',}
        if self.kind in kinds:
            if len(self.in_text) > 1:
                typeset_as = self.in_text[1]
            else:
                typeset_as = self.key
            #res.append('\\new%s{%s}{%d}{%s}{%s}' \
            #           % (kinds[self.kind], self.key, self.serial, typeset_as,
            #              self.in_text[0]))
            res.append('\\new%s{%s}{%s}{%s}' \
                       % (kinds[self.kind], self.key, typeset_as,
                          self.in_text[0]))
            
            #res.append('\\%sused{%s}' % (self.kind, self.key))
            
            equiv = self.get_equivalency(key)
            if equiv:
                (full_form, typeset_as) = \
                            self.expand_typeset_info(\
                    self.get_full_form_and_typeset_as(equiv.in_text))

                #print '(full_form, typeset_as) =', (full_form, typeset_as)

                if not full_form:
                    full_form = self.in_text[0]
                if not typeset_as:
                    typeset_as = (self.kind == 'person') \
                                 and self.in_text[1] \
                                 or full_form
                    
                res.append('\\new%sequiv{%s}{%s}{%s}{%s}' \
                           % (kinds[self.kind], self.key, typeset_as,
                              equiv.key, full_form))
                
        return res

class Equivalency(Concept):
    def __init__(self, key='', in_text='', #position = 'normal',
                 equivalencies=[], sort_as=None, serial=None):
        super(self.__class__, self).__init__(key, in_text,
                                             equivalencies, sort_as,
                                             'equivalency', serial=serial)

class InTeX(object):
    delimiter = '\t'
    
    def __init__(self, filenames):
        identifiers = dict()
        
        for filename in filenames:
            identifiers[filename] = self.parse(filename)
            
        self.index = dict()
        seen_kinds = dict()
        
        for filename, concepts in identifiers.items():
            for concept in concepts:
                seen_kinds[concept.kind] = True
                for key in concept.get_keys():
                    self.index[key] = concept
        
        self.identifiers = identifiers
        self.used_kinds = tuple(seen_kinds)
        
    def __contains__(self, key):
        return self.index.__contains__(key)

    def __getitem__(self, key):
        return self.index.__getitem__(key)

    def handle_fields(self, fields, kind, serial_number):
        info = {'serial': serial_number}
        
        key, fields = fields[0], fields[1:]
        
        info['key'] = key
        
        if fields and fields[-1][0] == '@':
            info['sort_as'] = fields.pop()[1:]

        info['in_text'] = tuple(fields)
        
        info['kind'] = kind

        #print >>sys.stderr, "Found info:", info
        return info

    def parse_line(self, line, concepts, kind, serial_number=0):
        if line[0].isspace():
            # An equivalent form of the current index entry.
            fields = self.handle_fields(line.lstrip().split(self.delimiter),
                                        kind, serial_number)
            del fields['kind']
            concepts[-1].add_equivalency(Equivalency(**fields))
            
        else:
            # A new index entry.  Can be 'person', 'acronym', or 'plain'.
            fields = self.handle_fields(line.split(self.delimiter),
                                        kind, serial_number)
            concepts.append(Concept(**fields))
            
    def parse(self, filename):
        concepts = []
        mode_switch_re = re.compile('^%[ ]*\*' \
                                    '(?P<kind>persons|acronyms|concepts)\*',
                                    re.IGNORECASE)
        kind = 'concept'                # Default "mode".

        serial_number = 1
        f = open(filename, 'r')
        for line in f:
            line = line.rstrip("\n")
            if not line:
                continue
            if line[0] == '%':
                m = mode_switch_re.match(line)
                if m:
                    # New current KIND (or mode).
                    kind = m.group('kind')[:-1].lower()
                continue
            
            self.parse_line(line, concepts, kind, serial_number)
            serial_number += 1
            
        f.close()
        
        return concepts

def get_entries(filename):
    global intex_re
    
    entries = []
    for line in open(filename, 'r'):
        m = intex_re.match(line.rstrip())
        if not m:
            yield (False, line)
            continue
        yield (True, m.groups())
        
def handle_auxiliary(aux_filename, index, index_file, tmp_aux_file):
    not_found = []
    already_handled = set()
    already_printed = set()
    
    for is_concept, data in get_entries(aux_filename):
        if not is_concept:
            tmp_aux_file.write(data)
            continue
        
        key, page = data
        
        if key not in index:
            not_found.append((key, page))
            continue
        
        concept = index[key]
        print >>index_file, concept.generate_index_entries(key, page)
        
        if key not in already_handled:
            aux_info = concept.generate_aux_modifications(key, page)
            for line in aux_info:
                if line not in already_printed:
                    print >>tmp_aux_file, line
                    already_printed.add(line)
                    
            already_handled.add(key)
            
    return not_found

def copy(src_name, dst_name):
    global READ_BUF_SIZE
    
    src, dst = open(src_name, 'r'), open(dst_name, 'w')
    while True:
        data = src.read(READ_BUF_SIZE)
        if data == '':
            break
        dst.write(data)
        
    dst.close()
    src.close()

auto_edit_warning ='''
%%%% This file was automatically generated by InTeX version %s,
%%%% copyright (C) 2005 by Martin Thorsen Ranang.  Any manual changes
%%%% made to this file will be lost next time InTeX is run with the
%%%% same arguments.
''' % (__version__)

def generate_acrodefs(index):
    res = []
    for identifier, concepts in index.identifiers.items():
        for concept in concepts:
            if concept.kind == 'acronym':
                if len(concept.in_text) > 1:
                    typeset_as = concept.in_text[1]
                else:
                    typeset_as = concept.key
                    
                res.append('\\newacronym{%s}{%s}{%s}' \
                           % (concept.key, typeset_as,
                              concept.in_text[0]))
    return res

def generate_persondefs(index):
    res = []
    for identifier, concepts in index.identifiers.items():
        for concept in concepts:
            if concept.kind == 'person':
                if len(concept.in_text) > 1:
                    res.append('\\newperson{%s}{%s}{%s}' \
                               % (concept.key, concept.in_text[1],
                                  concept.in_text[0]))
                else:
                    res.append('\\newperson{%s}{%s}' \
                               % (concept.key, concept.in_text[0]))
    return res

def main():
    """Module mainline (for standalone execution)."""
    command_line_options = [
        (['-o', '--index-output'],
         {'dest': 'index_output',
          'default': None,
          'metavar': 'FILE',
          'help': 'output the new indexing information to FILE'}),
        (['-a', '--acrodef-output'],
         {'dest': 'acrodef_output',
          'default': None,
          'metavar': 'FILE',
          'help': 'output acronym definitions to FILE'}),
        (['-p', '--persondef-output'],
         {'dest': 'persondef_output',
          'default': None,
          'metavar': 'FILE',
          'help': 'output (person) name definitions to FILE'}),
        (['-V', '--verbose'],
         {'dest': 'verbose',
          'default': False,
          'action': 'store_true',
          'help': 'whether or not to output verbose information'}),
        ]

                       
    options, args = parse_command_line(command_line_options)

    aux_re = re.compile('^.*\.aux$', re.IGNORECASE)
    auxiliary = [arg for arg in args
                 if aux_re.match(arg) and os.path.exists(arg)]
    args = [arg for arg in args if arg not in auxiliary]

    for attempt in xrange(2):
        if len(auxiliary) > 1:
            print >>sys.stderr, 'error: Please explicitly specify the ' \
                  'LaTeX auxiliary (.aux) file to use.'
            return 1
        elif not auxiliary:
            auxiliary = ['%s.aux' % (arg) for arg in args
                         if os.path.exists('%s.aux' % (arg))]
            args = [arg for arg in args if '%s.aux' % (arg) not in auxiliary]
        else:
            auxiliary = auxiliary[0]
            break

    if not auxiliary:
        print >>sys.stderr, 'warning: No LaTeX auxiliary file specified.'
        return 0

    if len(args) == 0:
        suffix_re = re.compile('^.*\.%s$' % (INTEX_EXT))
        
        filenames = [filename
                     for filename in os.listdir(os.getcwd())
                     if suffix_re.match(filename)]
    else:
        filenames = args
    
    for filename in filenames:
        if not os.path.exists(filename):
            print >>sys.stderr, "error: File '%s' not found" % (filename)
            return 1
        
    if options.verbose:
        print >>sys.stderr, 'LaTeX Auxiliary file: %s' % (auxiliary)
        print >>sys.stderr, 'Concept-files:\n%s' % '\n'.join(filenames)

    index = InTeX(filenames)

    for option, meta_information, kind in ((options.index_output,
                                            'index information',
                                            None),
                                           (options.acrodef_output,
                                            'acronym definitions',
                                            'acronym'),
                                           (options.persondef_output,
                                            '(proper)name definitions',
                                            'person')):
        if (kind and (kind in index.used_kinds) and (not option)):
            print >>sys.stderr, 'error: Missing name for file wherein ' \
                  '%s will be stored.' % (meta_information)
            return 1
        elif (kind and option and (kind not in index.used_kinds)):
            print >>sys.stderr, \
                  "warning: name for file wherein " \
                  "%s will be stored was\n" \
                  "         supplied ('%s'), but no such input occur" \
                  "." % (meta_information, option)

    persondef_file = open(options.persondef_output, 'w')
    print >>persondef_file, auto_edit_warning
    print >>persondef_file, '\n'.join(generate_persondefs(index))
    persondef_file.close()
    
    acrodef_file = open(options.acrodef_output, 'w')
    print >>acrodef_file, auto_edit_warning
    print >>acrodef_file, '\n'.join(generate_acrodefs(index))
    acrodef_file.close()
    
    index_file = open(options.index_output, 'w')
    
    # We first create a temporary file.  If any "shit hits the fan"
    # before we're done, the original LaTeX .aux file will be
    # untouched and the temporary version can be inspected.
    tmp_aux_fd, tmp_aux_filename = tempfile.mkstemp('.%s' % (INTEX_EXT))
    tmp_aux_file = os.fdopen(tmp_aux_fd, 'w')
    
    not_found = handle_auxiliary(auxiliary, index,
                                 index_file, tmp_aux_file)

    #     acrodef_file = open(options.acrodef_output, 'w')
    #     print >>acrodef_file, auto_edit_warning
    #print >>tmp_aux_file, '\n'.join(generate_acrodefs(index))
    #     acrodef_file.close()

    index_file.close()
    tmp_aux_file.close()
    
    # Everything seems to have worked OK so far.  Now, let's backup
    # the original .aux file and rename the temporarily created one to
    # take the place of the original.
    os.rename(auxiliary, '%s~' % (auxiliary))
    copy(tmp_aux_filename, auxiliary)
    os.unlink(tmp_aux_filename)
    
    if not_found:
        print >>sys.stderr, 'warning: The following phrases ' \
              'could not be handled:\n%s' \
              % ('\n'.join('%s\t%s' % item for item in not_found))
    
    return


if __name__ == "__main__":
    main()
